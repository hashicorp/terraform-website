---
page_title: 'Home - Plugin Development: Writing Log Output'
description: >-
  Write logs from your provider that help users debug issues and understand operations.
---

# Writing Log Output

Use the [`tflog` package](https://pkg.go.dev/github.com/hashicorp/terraform-plugin-log/tflog) to write logs for your provider. SDKs like the `terraform-plugin-framework`, `terraform-plugin-go`, and `terraform-plugin-sdk/v2` set up logging for you, so you only need to write the logs themselves.

!> **Warning:** Do not use `fmt.Println` and similar methods to log. They will silently fail, making the log output unavailable.

This page explains how to write log output at varying verbosity levels, add variables to logs, and designate logs that relate to distinct sections of code (e.g., the API client).

## Structured Logging

`tflog` uses _structured logging_, based on [`go-hclog`](https://pkg.go.dev/github.com/hashicorp/go-hclog). Rather that writing logs as sentences with embedded variabels and values, `tflog` takes a sentence describing the logging event and a set of variables to log. By separating the variables from the log description, you can programmatically parse, filter, and search your log output based on those variables. It also allows other parts of the system to associate variables with downstream log output.

## Logging Levels

You must choose a verbosity level for each line of log output. This lets you and other consumers [filter the log output](/plugin/log/filtering) from your provider by level. For example, you can set your provider to write only logs of type `Warn` during a Terraform run.

The following levels are listed from least verbose to most verbose.

### Error

Least verbose output that typically describes an unexpected condition that will halt execution. Often, they provide more information about a user-facing error.

```go
tflog.Error(ctx, "unrecognized API response body")
```

### Warn

Output that describes an unexpected condition, but not one that should halt execution. Warn log output is intended for warnings. Good candidates are deprecations or environment issues.

```go
tflog.Warn(ctx, "API returned a 500 error, retrying")
```

### Info

Output that describes a certain logic condition or event. Good candidates for info logging are details about the environment your provider is running in or how it has been configured to run.

```go
tflog.Info(ctx, "operating against API version 1.2.3")
```

### Debug

Verbose output that typically describes important operational details like milestones in logic. Good candidates for Debug logging are behaviors that may confusing even though they are correct.

```go
tflog.Debug(ctx, "found two identical diagnostics in the response, deduplicating down to one")
```

### Trace

The most verbose output that describes the lowest level details of operation, such as intra-function steps or raw data.

```go
tflog.Trace(ctx, "creating the widget")
resp, err := client.CreateWidget(ctx)
if err != nil {
  panic(err)
}
tflog.Trace(ctx, "created the widget")


## Variables

You can specify machine parseable `tflog` variables in the log output. To do this, add sets of key and value argument pairs after the log message. The example below adds a URL where a user could visit an API endpoint.

You can add as many key and value argument pairs as you need, but the key must always come before its associated value. The example below adds both a URL and a method for an associated API request.

```go
tflog.Trace(ctx, "executing API request", "url", "https://www.example.com/my/endpoint", "method", "POST")
```
You can use types other than strings as values, too:

```go
tflog.Trace(ctx, "executing API request", "url", "https://www.example.com/my/endpoint", "method", "POST", "size", 200, "authenticated", true, "headers", map[string][]string{"content-type": []string{"application/json"}})
```

## Injecting Variables

You can also "inject" variables into a logger. Loggers are transported using the `context.Context` variable, so injecting a variable into a logger returns a new `context.Context` variable containing the modified logger. Any calls to `tflog` using that logger will then implicitly include that variable.

```go
newContext := tflog.With(ctx, "url", "https://www.example.com/my/endpoint")

// won't include the `url` variable
tflog.Debug(ctx, "this won't have the url variable attached")

// will include the `url` variable
tflog.Debug(newContext, "this will have the url variable attached")
```

This allows provider developers to attach contextual information to logs, even when that contextual information isn't surfaced at the same place the log is being written. For example, the `terraform-plugin-go` library uses this capability to attach contextual information to assign a unique request ID to every RPC which is then included in all log output, allowing logs to be filtered on a per-request basis.

## Subsystems

When a section of code is sufficiently large or complex, or even when its logs are verbose but only sometimes needed, it can make sense to put it into its own subsystem. If they're configured to, these subsystems can be included or excluded from log output using environment variables. A good example of a subsystem may be logs that relate to the API client; sometimes you may need them, but when debugging provider code that's unrelated to that section of the codebase, they may get in the way or obscure things with how noisy they are.

When using a subsystem, it needs to be registered first:

```go
// my-subsystem is the name of the subsystem
// it will be attached to all your logs
ctx = tflog.NewSubsystem(ctx, "my-subsystem")
```

If you want your subsystem to have a different level from the rest of the provider logs, you can use an option for that:

```go
ctx = tflog.NewSubsystem(ctx, "my-subsystem", hclog.Debug)
```

If you don't want to hardcode the level but instead control it from an environment variable, there's an option for that, too:

```go
// read the level from TF_LOG_MYPROVIDER_CLIENT
ctx = tflog.NewSubsystem(ctx, "my-subsystem", tflog.WithLevelFromEnv("TF_LOG_MYPROVIDER_CLIENT"))
```

Then when writing logs, use the `Subsystem*` functions and pass in the same subsystem name:

```go
tflog.SubsystemDebug(ctx, "my-subsystem", "writing to a subsystem", "meaning_of_life", 42)
```

Just like with `tflog.With`, it's important that the `Subsystem*` functions get passed the context that is returned from `tflog.NewSubsystem`; the modified logger is stored in the context.
