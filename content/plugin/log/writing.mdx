---
page_title: 'Home - Plugin Development: Writing Log Output'
description: >-
  Write logs from your provider that help users debug issues and understand operations.
---

# Writing Log Output

Providers can write log output using [the `tflog` package](https://pkg.go.dev/github.com/hashicorp/terraform-plugin-log/tflog), which the SDKs set up and decorate with useful information.

!> **Warning:** Do not use `fmt.Println` and similar methods to log. They will silently fail and your log output will be unavailable.

## Structured Logging

`tflog` uses _structured logging_, based on [`go-hclog`](https://pkg.go.dev/github.com/hashicorp/go-hclog). Rather than having logs be sentences, with variables and values embedded in the sentence like `Printf` does, `tflog` takes a sentence describing what you're logging, and a set of variables to log. By separating the variables from the description of what's being logged, you can programmatically parse, filter, and search your log output based on those variables. It also allows other parts of the system to "decorate" log output, by associating variables with downstream log output.

## Logging Levels

To write log output, you need to decide what level the log output is:

### Trace

Trace log output is for low-level debugging of your provider's execution. It's meant to aid you in walking through exactly what code is executing so you can more easily follow what's happening. It's the most verbose output available.

```go
tflog.Trace(ctx, "creating the widget")
resp, err := client.CreateWidget(ctx)
if err != nil {
	panic(err)
}
tflog.Trace(ctx, "created the widget")
```

### Debug

Debug log output is for debugging your provider's execution. It's not quite as verbose as trace log output, but the information it exposes should only matter when debugging a provider's behavior. A good rule of thumb is that any "magic" behavior or anything that _may_ be confusing even though it's _correct_ is a good candidate for debug logging.

```go
tflog.Debug(ctx, "found two identical diagnostics in the response, deduplicating down to one")
```

### Info

Info log output is meant to be informative, but isn't necessarily related to debugging. Generally, a good candidate for info log output is information about the environment your provider is running in or how it's being configured to run. Info output is meant to be less verbose than debug output.

```go
tflog.Info(ctx, "operating against API version 1.2.3")
```

### Warn

Warn log output is intended for warnings. It doesn't, on its own, indicate an error; _technically_ everything's still fine. But there's a solid chance things may not be fine, or at some future point won't be fine, and this is your breadcrumb pointing to why that may be the case. A good candidate for warning logs is environment problems that can be automatically recovered from or deprecations. Warning logs are meant to be less verbose than info logs.

```go
tflog.Warn(ctx, "API returned a 500 error, retrying")
```

### Error

Error log output is intended for situations in which a user-facing error is likely to be surfaced. They provide more information, often for a developer audience instead of a practitioner audience, about the error in question. Error logs are the least verbose logs available.

```go
tflog.Error(ctx, "unrecognized API response body")
```

## Variables

You can specify machine parseable `tflog` variables in the log output. To do this, add sets of key and value argument pairs after the log message. The example below adds a URL where a user could visit an API endpoint.

```go
tflog.Trace(ctx, "executing API request", "url", "https://www.example.com/my/endpoint")
```

You can add as many key and value argument pairs as you need, but the key must always come before its associated value. The example below adds both a URL and a method for an associated API request.

```go
tflog.Trace(ctx, "executing API request", "url", "https://www.example.com/my/endpoint", "method", "POST")
```

You can use types other than strings as values, too:

```go
tflog.Trace(ctx, "executing API request", "url", "https://www.example.com/my/endpoint", "method", "POST", "size", 200, "authenticated", true, "headers", map[string][]string{"content-type": []string{"application/json"}})
```

## Injecting Variables

You can also "inject" variables into a logger. Loggers are transported using the `context.Context` variable, so injecting a variable into a logger returns a new `context.Context` variable containing the modified logger. Any calls to `tflog` using that logger will then implicitly include that variable.

```go
newContext := tflog.With(ctx, "url", "https://www.example.com/my/endpoint")

// won't include the `url` variable
tflog.Debug(ctx, "this won't have the url variable attached")

// will include the `url` variable
tflog.Debug(newContext, "this will have the url variable attached")
```

This allows provider developers to attach contextual information to logs, even when that contextual information isn't surfaced at the same place the log is being written. For example, the `terraform-plugin-go` library uses this capability to attach contextual information to assign a unique request ID to every RPC which is then included in all log output, allowing logs to be filtered on a per-request basis.

## Subsystems

When a section of code is sufficiently large or complex, or even when its logs are verbose but only sometimes needed, it can make sense to put it into its own subsystem. If they're configured to, these subsystems can be included or excluded from log output using environment variables. A good example of a subsystem may be logs that relate to the API client; sometimes you may need them, but when debugging provider code that's unrelated to that section of the codebase, they may get in the way or obscure things with how noisy they are.

When using a subsystem, it needs to be registered first:

```go
// my-subsystem is the name of the subsystem
// it will be attached to all your logs
ctx = tflog.NewSubsystem(ctx, "my-subsystem")
```

If you want your subsystem to have a different level from the rest of the provider logs, you can use an option for that:

```go
ctx = tflog.NewSubsystem(ctx, "my-subsystem", hclog.Debug)
```

If you don't want to hardcode the level but instead control it from an environment variable, there's an option for that, too:

```go
// read the level from TF_LOG_MYPROVIDER_CLIENT
ctx = tflog.NewSubsystem(ctx, "my-subsystem", tflog.WithLevelFromEnv("TF_LOG_MYPROVIDER_CLIENT"))
```

Then when writing logs, use the `Subsystem*` functions and pass in the same subsystem name:

```go
tflog.SubsystemDebug(ctx, "my-subsystem", "writing to a subsystem", "meaning_of_life", 42)
```

Just like with `tflog.With`, it's important that the `Subsystem*` functions get passed the context that is returned from `tflog.NewSubsystem`; the modified logger is stored in the context.
