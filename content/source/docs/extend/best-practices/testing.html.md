---
layout: "extend"
page_title: "Extending Terraform: Best Practices"
sidebar_current: "docs-extend-best-practices-testing"
description: |-
  Extending Terraform is a section for content dedicated to developing Plugins
  to extend Terraform's core offering.
---

# Testing Best Practices
In [Testing Terraform Plugins][1] we introduce Terraform’s Testing Framework,
providing reference for its functionality and introducing the basic parts of
writing acceptance tests. In this section we’ll cover some test patterns that
are common and considered a best practice to have when developing and verifying
your Terraform plugins. At time of writing these guides are particular to
Terraform Resources, but other testing best practices may be added later. 

###Built-in patterns

Acceptance tests use [TestCases][2] to construct scenarios that can be evaluated
with Terraform’s lifecycle of plan, apply, refresh, and destroy. The test
framework has some behaviors built in that provide very basic workflow assurance
tests, such as verifying configurations apply with no diff generated by the next
plan.

Each TestCase will run any [PreCheck][3] function provided before running the
test, and then any [CheckDestroy][4] functions after the test concludes. These
functions allow developers to verify the state of the resource and test before
and after it runs. 

When a test is ran, Terraform runs plan, apply, refresh, and then final plan for
each [TestStep][5] in the TestCase. If the last plan results in a non-empty
plan, Terraform will exit with an error. This enables developers to ensure that
configurations apply cleanly. In the case of introducing regression tests or
otherwise testing specific error behavior, TestStep offers a boolean field
[ExpectNonEmptyPlan][6] as well [ExpectError][7] regex field to specify ways the
test framework can handle expected failures. If these properties are omitted and
either a non-empty plan occurs or an error encountered, Terraform will fail the
test. 

After all TestSteps have been ran, Terraform then runs destroy, and ends by
running any CheckDestroy function provided.

##Basic test to verify attributes

The most basic resource acceptance test should use what is likely a common
configuration and verify that Terraform correctly created the resource, and that
resources attributes are what Terraform expects them to be. At a high level, the
first basic test for a resource should establish the following:

Terraform can plan and apply a common resource configuration without error
Verify the expected attributes are saved to state, and contain the values
expected. Verify the values in the remote API/Service for the resource match
what is stored in state Verify that a subsequent terraform plan does not produce
a diff/change


##Test to verify configuration updates


##Expecting errors or non-empty plans


#Conclusion 

Terraform’s [Testing Framework][1] allows for powerful, iterative
acceptance tests that enable developers to fully test the behavior of Terraform
plugins. By following the above best practices, developers can ensure their
plugin behavies correctly across the most common use cases and everyday
operations users will have using their plugins, and ensure that Terraform
remains a world-class tool for safely managing infrastructure. 



[1]: /docs/extend/testing/index.html
[2]: /docs/extend/testing/acceptance-tests/testcase.html
[3]: /docs/extend/testing/acceptance-tests/testcase.html#precheck
[4]: /docs/extend/testing/acceptance-tests/testcase.html#checkdestroy
[5]: /docs/extend/testing/acceptance-tests/teststep.html
[6]: https://github.com/hashicorp/terraform/blob/9441e78fb9c35037da71fd0284b97e546dd6a53b/helper/resource/testing.go#L299-L301
[7]:  https://github.com/hashicorp/terraform/blob/9441e78fb9c35037da71fd0284b97e546dd6a53b/helper/resource/testing.go#L303-L306
